#  [堆](https://time.geekbang.org/column/article/69913)

## 堆的特点

> * 堆是一个完全二叉树；
> * 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。



## 如何实现一个堆？

> 数组实现

用数组来存储完全二叉树是非常节省存储空间的,因为我们不需要存储左右子节点的指针,单纯的通过数组的下标,就可以找到一个节点的左右子节点和父节点

## 堆上的操作有哪些呢？

* 插入元素

  > 自下而上: 把插入元素放在数组末尾,再进行比较

* 删除堆顶元素

  > 自上而下: 删除堆顶元素后,把最后一个元素放入堆顶,再进行比较

* 堆化

> 往堆里面插入数据后,需要保持堆的两个特点,所以需要在插入之后进行**堆化**操作

![img](https://static001.geekbang.org/resource/image/e5/22/e578654f930002a140ebcf72b11eb722.jpg)

![img](https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg)



## 堆操作的时间复杂度分析-O(logn)

一个包含 n 个节点的完全二叉树，树的高度不会超过 log2n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。



## [堆的应用](https://time.geekbang.org/column/article/70187)

### 1.堆排序

> 我们借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法。

* **建堆 & 排序**

### 2.如何快速获取到Top 10最热门的搜索关键词？

> 我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？

散列表 + 小顶堆 (求TopK)

想要节省空间: 散列表+hash(搜索关键字)+小顶堆(求TopK)+ hash拆分文件

> 我们可以根据哈希算法的这个特点，将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。具体可以这样做：我们创建 10 个空文件 00，01，02，……，09。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。

### 3.优先级队列

> 首先是个队列,每次插入都会触发排序操作, 所以本质上就是个会自动排序的队列啦

### 4.利用堆求 Top K---(小顶堆)

> 针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。

### 5.利用堆求中位数(百分位)--- (小顶堆,大顶堆)

**第一步: 先从小到大排序**

> 我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。

## 内容小结:

今天我们讲了堆这种数据结构。堆是一种完全二叉树。它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。

堆中比较重要的两个操作是**插入一个数据和删除堆顶元素**。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 O(logn)。